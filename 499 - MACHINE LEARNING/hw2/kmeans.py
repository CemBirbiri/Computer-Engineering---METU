# -*- coding: utf-8 -*-
"""kmeans

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kIFzM1lSNNS2pZH4SrctFO5RCb9Avhh4
"""

#Loading data on Google Colab:
#!wget user.ceng.metu.edu.tr/~artun/ceng499/hw2_data.zip
#!unzip hw2_data.zip

import numpy as np
data1 = np.load( "/content/hw2_data/kmeans/clustering1.npy" )
data2 = np.load( "/content/hw2_data/kmeans/clustering2.npy" )
data3 = np.load( "/content/hw2_data/kmeans/clustering3.npy" )
data4 = np.load( "/content/hw2_data/kmeans/clustering4.npy" )

def is_in(element1, list1):
  for i in range(0,len(list1)):
    if list1[i][0]==element1[0] and list1[i][1]==element1[1]:
      return 1
  return 0

def euclidean_dist(x1,x2):
  x1 = np.array(x1) 
  x2 = np.array(x2) 
  sum_sq = np.sum(np.square(x1 - x2)) 
  return np.sqrt(sum_sq) 

def choose_cluster_centers(dataset, k):
    np.random.seed(42)
    centroids = []
    m = np.shape(dataset)[0]      
    i=0
    while i!=k:
      r = np.random.randint(0, m-1)
      if is_in(dataset[r],centroids)==0:
        centroids.append(dataset[r])
        i=i+1
    return np.array(centroids)
################################################################################
################################################################################
def find_new_centroids(datapoints_and_cents, it,k):
  #print("finding new centroids begin","k=",k,"it=",it)
  old_centroids=[]
  
  
  #first, find old centroids
  for i in range(0,len( datapoints_and_cents)):
    if is_in(datapoints_and_cents[i][1],old_centroids)==0:
      old_centroids.append(datapoints_and_cents[i][1])

  groups=[]
  for i in range(0,len(old_centroids)):
    groups.append([])

  #put together datapoints that are labeled to the same centroid
  for i in range(0,len( datapoints_and_cents)):
    for j in range(0,len(old_centroids)):
      if datapoints_and_cents[i][1][0]==old_centroids[j][0] and datapoints_and_cents[i][1][1]==old_centroids[j][1]:
        groups[j].append(datapoints_and_cents[i][0])
        break
 
 #find new centroids
  new_centroids2=[]
  avg_cents=[]
  #first,find avg. centroids
  for i in range(0,len(groups)):
    groups[i]=np.array(groups[i])
    avg= sum(groups[i])/len(groups[i])
    avg_cents.append(avg)
  min_dist=9999
  new_cent=(0,0)
  #find the centroids that is closest to avg centroids
  for i in range(0,len(groups)):
    new_cent=(0,0)
    min_dist=9999
    for j in range(0,len(groups[i])):
      if euclidean_dist(avg_cents[i], groups[i][j])< min_dist:
        min_dist = euclidean_dist(avg_cents[i], groups[i][j])
        new_cent=groups[i][j]
    new_centroids2.append(new_cent)
  return new_centroids2


def sum_of_squared_dist(tuuple):
  r=((tuuple[0][0]-tuuple[1][0])*(tuuple[0][0]-tuuple[1][0]))+ ((tuuple[0][1]-tuuple[1][1])*(tuuple[0][1]-tuuple[1][1]))
  return r
################################################################################
################################################################################

def kmeans(num_iteration, k_kmeans, dataset):

  objective_func_result=0
  centroids=choose_cluster_centers(dataset,k_kmeans)
  for it in range(0,num_iteration):#number of iterations
    datapoints_and_cents=[]
    #print("it=",it," starts", "k=",k_kmeans)

    flag=1
    for dp in range(0, len(dataset)): #for each datapoint(dp) in the dataset, calculate distance to centroids
      distances=[]
      flag=1
      for i in range(0,len(centroids)):#if the data point is equal to one of the centroid,th skip that data point
        if centroids[i][0]==dataset[dp][0] and centroids[i][1]==dataset[dp][1]:
          flag==0
      if flag==1:
        for cents in range(0,len(centroids)):
          dist= euclidean_dist(centroids[cents],dataset[dp])
          distances.append((centroids[cents], dist))
      
        distances=sorted(distances, key=lambda x: x[1])
        label_cent=distances[0][0]
        datapoints_and_cents.append((dataset[dp], label_cent)) 
    #find new centroids
    

    new_centroids=find_new_centroids(datapoints_and_cents,it,k_kmeans)
    
    centroids=new_centroids

    #print("it=",it," ends "," k=",k_kmeans,"-finding new centroids")

    for i in range(0,len(datapoints_and_cents)):
      euc_dist= euclidean_dist(datapoints_and_cents[i][0],datapoints_and_cents[i][1])
      objective_func_result+= euc_dist*euc_dist

  return objective_func_result/10, datapoints_and_cents




############################################################
############################################################ 
############################################################
num_iteration=10
dataset=data4

all_objectives=[]
#for k_kmeans in range(3,4):#this is after selecting the best k value for datasets
for k_kmeans in range(1,11):
  print("k=",k_kmeans)
  objective_func_result, datapoints_and_cents = kmeans(num_iteration,k_kmeans,dataset)
  all_objectives.append(objective_func_result)
############################################################
############################################################
############################################################

#Visualize the objective function values
import matplotlib.pyplot as plt
plt.plot(all_objectives, label='objective results')
plt.legend()




########## !!!!! ###############
#################################
# The part below is for datasets' color versions of the plots.
#This part is not used when different k values are tried.
#################################
############ !!!!! ################
'''
final_centroids=[]
  
  #first, find old centroids
for i in range(0,len( datapoints_and_cents)):
  if is_in(datapoints_and_cents[i][1],final_centroids)==0:
    final_centroids.append(datapoints_and_cents[i][1])

grouping_datapoints=[]
for i in range(0,len(final_centroids)):
  grouping_datapoints.append([])

#put together datapoints that are labeled to the same centroid
for i in range(0,len( datapoints_and_cents)):
  for j in range(0,len(final_centroids)):
    if datapoints_and_cents[i][1][0]==final_centroids[j][0] and datapoints_and_cents[i][1][1]==final_centroids[j][1]:
      grouping_datapoints[j].append(datapoints_and_cents[i][0])



#################################################
import matplotlib.pyplot as plt
fig=plt.figure(figsize=(8,8), dpi=80, facecolor='w', edgecolor='k')
x1=[]# use x1 if k>=1 
for i in range(0,len(grouping_datapoints[0])):
  p1= np.array([grouping_datapoints[0][i][0], grouping_datapoints[0][i][1]] )
  x1.append(p1 )
x1=np.array(x1)
plt.scatter(x1[:, 0], x1[:, 1],color='m');


x2=[]# use x1 if k<=2
for i in range(0,len(grouping_datapoints[1])):
  p2= np.array([grouping_datapoints[1][i][0], grouping_datapoints[1][i][1]] )
  x2.append(p2 )
x2=np.array(x2)
plt.scatter(x2[:, 0], x2[:, 1],color='green');

x3=[]# use x1 if k>=3
for i in range(0,len(grouping_datapoints[2])):
  p3= np.array([grouping_datapoints[2][i][0], grouping_datapoints[2][i][1]] )
  x3.append(p3 )
x3=np.array(x3)
plt.scatter(x3[:, 0], x3[:, 1],color='blue');


x4=[]# use x1 if k>=4 
for i in range(0,len(grouping_datapoints[3])):
  p4= np.array([grouping_datapoints[3][i][0], grouping_datapoints[3][i][1]] )
  x4.append(p4 )
x4=np.array(x4)
plt.scatter(x4[:, 0], x4[:, 1],color='y');

x5=[] # use x1 if k>=5 (if there is 5 clusters then use x5)
for i in range(0,len(grouping_datapoints[4])):
  p5= np.array([grouping_datapoints[4][i][0], grouping_datapoints[4][i][1]] )
  x5.append(p5 )
x5=np.array(x5)
plt.scatter(x5[:, 0], x5[:, 1],color='c');


#plotting centroids
final_centroids=np.array(final_centroids)
plt.scatter(final_centroids[:,0], final_centroids[:,1], marker="D", color='k')
'''