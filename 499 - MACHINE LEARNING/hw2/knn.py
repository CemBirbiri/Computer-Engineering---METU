# -*- coding: utf-8 -*-
"""k_nearest_neighbor

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pj3EKmVv9anZk41czAFpTNpbDjfi08Q9
"""






##########################################
##########################################
# Run : python3 k_nearest_neighbor.py
# I used Google Colab so the data paths below belongs to Colab
##########################################
##########################################
#Loading data on Google Colab:
#!wget user.ceng.metu.edu.tr/~artun/ceng499/hw2_data.zip
#!unzip hw2_data.zip

import numpy as np
train_data = np.load( "/content/hw2_data/knn/train_data.npy" )
train_labels = np.load( "/content/hw2_data/knn/train_labels.npy" )
test_data = np.load( "/content/hw2_data/knn/test_data.npy" )
test_labels = np.load( "/content/hw2_data/knn/test_labels.npy" )

def prepare_10FoldCrossVal_data(train_data, train_labels):
  #Divide the dataset into 10 equal chunks
  x1=train_data[0:25]
  y1=train_labels[0:25]

  x2=train_data[25:50]
  y2=train_labels[25:50]

  x3=train_data[50:75]
  y3=train_labels[50:75]

  x4=train_data[75:100]
  y4=train_labels[75:100]

  x5=train_data[100:125]
  y5=train_labels[100:125]

  x6=train_data[125:150]
  y6=train_labels[125:150]

  x7=train_data[150:175]
  y7=train_labels[150:175]

  x8=train_data[175:200]
  y8=train_labels[175:200]

  x9=train_data[200:225]
  y9=train_labels[200:225]

  x10=train_data[225:250]
  y10=train_labels[225:250]
  x_all=[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10]
  y_all=[y1,y2,y3,y4,y5,y6,y7,y8,y9,y10]
  return x_all, y_all

def euclidean_dist(x1,x2):
  x1 = np.array(x1) 
  x2 = np.array(x2) 
  sum_sq = np.sum(np.square(x1 - x2)) 
  return np.sqrt(sum_sq) 


def knn_train(x_all,y_all,j,k_knn):
  #########################################
  #j is the index of validation dataset
  #
  #Prepare the training and validation datasets
  x_train=[]
  y_train=[]
  x_val=[]
  y_val=[]
  for i0 in range(0,10):
    if i0!=j:  #get training data points
      for k in range(0,25):
        x_train.append(x_all[i0][k])
        y_train.append(y_all[i0][k])
    else:
      x_val=x_all[i0]
      y_val=y_all[i0]
  #########################################
  val_labels=[]
  for i in range(0,25): #for every element in val dataset
    distances=[]
    zero=0
    one=0
    two=0
    for r in range(0,225):
      #for every data-point in val dataset, find the distance between every data-point
      dist= euclidean_dist(x_val[i],x_train[r])
      distances.append((x_train[r], y_train[r], dist))
    distances=sorted(distances, key=lambda x: x[2]) #sort ascending order
    distances=distances[0:k_knn] #take k-nearest neighboor
    
    ##################################################################
    ####    finding label    ###########################################
    for i1 in range(0,len(distances)):
      if distances[i1][1]==0:
        zero=zero+1
      elif distances[i1][1]==1:
        one=one+1
      elif distances[i1][1]==2:
        two=two+1
    
    temp=[0,0,0]
    temp[0]=zero
    temp[1]=one
    temp[2]=two
    maximum=max(temp)
    if maximum==temp[0]:
      label=0
    elif maximum==temp[1]:
      label=1
    elif maximum==temp[2]:
      label=2

    val_labels.append((x_val[i], y_val[i], label))
    ##################################################################
  
  #below, I calculate the accuracy
  true_labels=0
  false_labels=0
  for i2 in range(0,25):
    if val_labels[i2][1]==val_labels[i2][2]:#if predicted label and true label match
      true_labels+=1 
    else:
      false_labels+=1
  
  return true_labels/25


x_all,y_all= prepare_10FoldCrossVal_data(train_data, train_labels)
accuracies=[]

final_accuracies=[]
for k_knn in range(1,200,2):#try k values in the range [1,199]
  accuracies=[]
  for j in range(0,10): #10-fold cross validation
    accuracies.append(knn_train(x_all,y_all,j, k_knn))
  final_accuracy= sum(accuracies)/10.0
  #print(final_accuracy)
  final_accuracies.append((k_knn, final_accuracy))
  

#find the max accuracy and corresponding k value
maxx_acc=0
temp_max=0
for i in range(0,len(final_accuracies)):
  if final_accuracies[i][1]>maxx_acc:
    maxx_acc= final_accuracies[i][1]
    temp_max=final_accuracies[i]

print("Best accuracy= ",temp_max[1]  ,"and corresponding k value=",temp_max[0])



#get all accuracies for the visualization(plotting)
accs_for_visualization=[]
for i in range(0,len(final_accuracies)):
  accs_for_visualization.append(final_accuracies[i][1])




#Visualize
import matplotlib.pyplot as plt
plt.plot(accs_for_visualization, label='KNN accuracies')
plt.legend()
plt.show()


#Testing KNN
def knn_test(train_data ,train_labels, test_data, test_labels, k_knn):

  labels_result=[]
  for i in range(0,200): #for every element in test dataset
    distances=[]
    zero=0
    one=0
    two=0
    for r in range(0,250):
      #for every data-point in test dataset, find the distance between every data-point
      dist= euclidean_dist(test_data[i],train_data[r])
      distances.append((train_data[r], train_labels[r], dist))
    distances=sorted(distances, key=lambda x: x[2]) #sort ascending order
    distances=distances[0:k_knn] #take k-nearest neighboor(for testing k=11)
    
    ##################################################################
    ####    finding label    ###########################################
    for i1 in range(0,len(distances)):
      if distances[i1][1]==0:
        zero=zero+1
      elif distances[i1][1]==1:
        one=one+1
      elif distances[i1][1]==2:
        two=two+1
    
    temp=[0,0,0]
    temp[0]=zero
    temp[1]=one
    temp[2]=two
    maximum=max(temp)
    if maximum==temp[0]:
      label=0
    elif maximum==temp[1]:
      label=1
    elif maximum==temp[2]:
      label=2

    labels_result.append((test_data[i], test_labels[i], label))
    ##################################################################
  
  #below, I calculate the accuracy
  true_labels=0
  false_labels=0
  for i2 in range(0,25):
    if labels_result[i2][1]==labels_result[i2][2]:#if predicted label and true label match
      true_labels+=1 
    else:
      false_labels+=1
  
  return true_labels/25

print("test accuracy = ", knn_test(train_data ,train_labels, test_data, test_labels, 11))